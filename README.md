[![Repo Preview](https://img.shields.io/badge/GitHub-Repository-blue?logo=github)](https://github.com/alixchan/storagedb)

Рассмотрим механику работы - небольшой и примитивный тест, который вызывает функцию определения размера хранилища. Вначале создается экземпляр объекта StorageDB, то есть наше хранилище, используя паттерн Строитель, выполняя несколько конфигураций (1.1, 1.2, 1.3 на рисунке ниже соответственно). Вызов build() создает и возвращает экземпляр объекта StorageDB с указанными параметрами конфигурации. В ходе выполнения этого конструкта создается реализация индексной структуры по умолчанию (1.4.1.1), WAL (1.4.1.2), пула объектов для управления файлами (1.4.1.3). Далее тест запрашивает размер базы данных (1.5). В конце db.close() вызывается для закрытия базы данных после выполнения теста. Это важно для правильного освобождения ресурсов и предотвращения утечек памяти. В рамках этого процесса осуществляется вызов метода flush() (1.6.1), который выполняет операцию сброса буфера записи на постоянное хранилище журнала записей (WAL) и производит некоторые проверки и обновления состояния, в рамках чего flush() класса Buffer используется для записи данных из буфера в выходной поток, а clear() используется для очистки буфера, устанавливая его в исходное состояние.

StorageDBBuilder представляет собой строитель (паттерн Builder) для создания экземпляра класса StorageDB. StorageDB является частью storage engine и предоставляет функциональность для управления базой данных. Этот структурный элемент предоставляет собой удобный способ настроить и создать экземпляр StorageDB с заданными параметрами конфигурации, что позволяет гибко управлять хранилищем данных.
StorageDB является реализацией базы данных хранилища ключей и значений. Он предоставляет методы для чтения, записи и управления дан-ными в базе данных. Основная цель этого класса — эффективное хранение и извлечение пар ключ-значение, а также выполнение сжатия БД и восста-новления после сбоев, используя файлы для хранения данных и журнала транзакций, а также буфер для временного хранения записей перед их за-писью на диск. Он использует IndexMap для отслеживания расположения каждого значения в файле данных или файле WAL через отображение ключей на смещение данных в файлах. Он также использует буфер для оп-тимизации записи и периодически сбрасывает буфер на диск. Кроме того, он реализует фоновый поток для уплотнения (объединения файлов данных для уменьшения количества небольших файлов и повышения производи-тельности чтения) и позволяет использовать пул потоков для выполнения фоновых операций ExecutorService.
Config, CompactionState нужны для задания параметров системы. Также написаны утилиты для работы с файлами, добавлены ряд дополни-тельных исключений и утилиты для восстановления данных и адресных вычислений.
Buffer представляет собой буфер, используемый для записи данных в файл журнала записей WAL и последующей записи их на диск. Он предна-значен для работы с буфером записей в оперативной памяти. Буфер пред-ставляет собой логическое продолжение файла WAL, и если индекс указы-вает на смещение, большее, чем у фактического файла WAL, то предполагается, что данные находятся в буфере записи. Роль класса следующая:
•	представляет буфер, который используется для временного хранения записей перед их записью на диск. Он служит промежуточным хранилищем для изменений данных, которые будут позже записаны на постоянное хранилище (в файле WAL).
•	предоставляет методы для выполнения операций чтения и за-писи данных в буфер. Он позволяет добавлять новые записи с указанными ключами и значениями в буфер, а также обновлять существующие записи по ключу.
•	управляет выделением и освобождением памяти для хранения записей в буфере. Он выделяет достаточное количество памяти для хранения записей, основываясь на заданной конфигурации и размерах записей.
•	отвечает за вставку маркеров синхронизации в буфер, чтобы обеспечить целостность данных при записи на диск. Маркеры синхронизации помогают отслеживать границы блоков записей и обеспечивают целостность данных при чтении.
•	предоставляет методы для последовательного доступа к запи-сям в буфере. Это удобно для выполнения операций обхода или обработки записей в буфере.

Класс BlockUtility представляет собой утилиту для выполнения опе-раций над блоками в файле, таких как восстановление блоков из повре-жденного файла. Метод rewriteBlocks(File file, int valueSize) выполняет пе-резапись блоков в файле для восстановления данных с использованием RandomAccessFile, который позволяет читать исходный файл по произ-вольному смещению и записывать данные в определенные позиции, а так-же ArrayDeque<Byte>, которая используется для хранения байтов синхро-низационного маркера, чтобы осуществлять проверку соответствия син-хронизационному маркеру в блоках данных. При этом, происходит вы-числение контрольной суммы CRC32 для каждого блока данных, тем са-мым проверяется целостность данных путем сравнения контрольной сум-мы с сохраненной в файле. Восстановленные блоки записываются в новый файл recoveredFile, включая синхронизационный маркер, данные и кон-трольную сумму. Метод verifyBlocks(File file, int valueSize) выполняет уже непосредственную проверку блоков в файле (на соответствие синхрониза-ционному маркеру и контрольной сумме) и, при необходимости, выполня-ет восстановление с помощью вышеуказанного метода, затем восстанов-ленный файл переименовывается и заменяет исходный файл.
Класс Buffer представляет собой буфер для записи в файл журнала Write-Ahead Logging (WAL), который представлен на Рис. 20 и который использует ByteBuffer для хранения данных буфера и работы с ними эф-фективным способом. В конструкторе класса происходит расчет макси-мального числа записей, которые могут поместиться в буфер. Расчет осно-ван на конфигурации базы данных и размере значений. Значение макси-мального числа записей выравнивается до ближайшего кратного числа 128. Размер буфера рассчитывается на основе числа записей, размера каждой записи, размера CRC и маркеров синхронизации. При записи дан-ных в буфер выполняется проверка на режим только для чтения и добав-ление маркеров синхронизации при необходимости. Методы readFromFiles() и readFromFile() используются для чтения данных из фай-лов, а метод flush() используется для сброса содержимого буфера в ука-занный выходной поток. Метод closeBlock() вызывается при закрытии те-кущего блока буфера и вычисляет и обновляет значение CRC32 для блока данных, что позволяет проверить целостность данных при чтении.

Класс StorageDB представляет базу данных хранилища ключ-значение, которая сохраняет данные в файле базы дан-ных и предоставляет гибкие методы и свойства для настройки параметров базы данных, таких как размер буфера, интервал фоновой операции, раз-мер пула случайного доступа к файлу и другие. Это позволяет пользова-телю адаптировать класс к своим потребностям и оптимизировать его про-изводительность. Класс использует ReentrantReadWriteLock для синхрони-зации операций чтения и записи базы данных, что позволяет одновремен-но выполнять множество операций чтения и обеспечивает эксклюзивный доступ к операциям записи, а также RandomAccessFilePool для управления доступом к файлам, так как он позволяет переиспользовать и повторно от-крывать файлы базы данных для оптимального управления ресурсами. Кроме того, содержит буфер (объект Buffer), - здесь он нуден, чтобы сни-зить количество операций записи на диск путем сбора нескольких записей в одну пакетную операцию. Класс содержит методы shouldCompact() и compact(), которые определяют, когда необходимо выполнять операцию сжатия (компактации) базы данных, для сжатия данных и устранения фрагментации, что позволяет улучшить производительность и эффектив-ность базы данных, а также содержит фоновую операцию, выполняющую автоматическую компактацию и сброс буфера на диск в заданных интер-валах времени. Фоновая операция выполняется в отдельном потоке и управляется с помощью флагов shutDown и useExecutorService. Для ис-пользования ExecutorService содержится метод initExecutorService(), кото-рый инициализирует пул потоков ExecutorService для выполнения фоно-вых операций. Пул потоков позволяет эффективно использовать ресурсы системы и параллельно выполнять операции на нескольких потоках. Класс также использует механизмы сериализации и десериализации, такие как ObjectInputStream и ObjectOutputStream, для сохранения и загрузки объ-ектов данных в файл базы данных. Класс StorageDB обрабатывает раз-личные ошибки, такие как ошибки доступа к файлу, исключения сериали-зации/десериализации и другие исключения, возникающие при работе с базой данных, предоставляя возможности восстановления после ошибок и внутреннюю целостность данных. Общими чертами всех этих решений яв-ляются учет производительности, эффективного использования ресурсов и обеспечение надежности базы данных хранилища ключ-значение. Класс StorageDB представляет собой комплексное решение, которое может быть использовано в различных приложениях, где требуется сохранение дан-ных в файловой системе.
